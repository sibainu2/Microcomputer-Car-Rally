/***********************************************************************/
/*                                                                     */
/*  FILE        :mikami_ryou_BASIC.c                                   */
/*  DATE        :Thu, Apr 01, 2021                                     */
/*  DESCRIPTION :main program file.                                    */
/*  CPU GROUP   :38C                                                   */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.19).    */
/*  NOTE:THIS IS A TYPICAL EXAMPLE.                                    */
/***********************************************************************/

/*
このプログラムは、下記基板に対応しています。
・RY_R8C38ボード
・モータドライブ基板Ver.5
・センサ基板Ver.5
*/

/*======================================*/
/* インクルード                         */
/*======================================*/
#include "sfr_r838a.h"                  /* R8C/38A SFRの定義ファイル    */

/*======================================*/
/* シンボル定義                         */
/*======================================*/

/* 定数設定 */
#define PWM_CYCLE       39999           /* モータPWMの周期              */
//#define SERVO_CENTER    3685            /* サーボのセンタ値             */
#define SERVO_CENTER   4600//3210            /* サーボのセンタ値  4500以上5000以下           */
#define HANDLE_STEP     25              /* 1゜分の値                    */


#define CV_S  5
#define CV_M  15
#define CV_L  20
#define CV_VL 35

/*
#define CV_S  3//10
#define CV_M  10//30
#define CV_L  12//38
#define CV_VL 14//44
/*

/* センタ→まっすぐ */
#define M_MASSUGU	motor( 100 ,100 );
/* 右へ微曲げ */
#define M_MIGI_BI	motor( 100 ,diff(100) );
/* 右へ小曲げ */
#define M_MIGI_KO	motor( 90 ,diff(90) );
/* 右へ中曲げ */
#define M_MIGI_CHU	motor( 80 ,diff(80) );
/* 右へ大曲げ */
#define M_MIGI_OO	motor( 70 ,diff(70) );


/* 左へ微曲げ */
#define M_HIDARI_BI	 motor( diff(100) ,100);
/* 左へ小曲げ */
#define M_HIDARI_KO	 motor( diff(90) ,90 );
/* 左へ中曲げ */
#define M_HIDARI_CHU 	motor( diff(80) ,80 );
/* 左へ大曲げ */
#define M_HIDARI_OO	 motor( diff(70) ,70);

/* クランクの速度 */
#define CR_SPEED	30
/*クランクをカウントする*/
int CR_COUNT=1;

/* レーンチェンジの速度 */
#define LC_SPEED	40


/* マスク値設定 ×：マスクあり(無効)　○：マスク無し(有効) */
#define MASK2_2         0x66            /* ×○○××○○×             */
#define MASK2_0         0x60            /* ×○○×××××             */
#define MASK0_2         0x06            /* ×××××○○×             */
#define MASK3_3         0xe7            /* ○○○××○○○             */
#define MASK0_3         0x07            /* ×××××○○○             */
#define MASK3_0         0xe0            /* ○○○×××××             */
#define MASK4_0         0xf0            /* ○○○○××××             */
#define MASK0_4         0x0f            /* ××××○○○○             */
#define MASK4_4         0xff            /* ○○○○○○○○             */

/*======================================*/
/* プロトタイプ宣言                     */
/*======================================*/
void init( void );
void timer( unsigned long timer_set );
int check_crossline( void );
int check_rightline( void );
int check_leftline( void );
unsigned char sensor_inp( unsigned char mask );
unsigned char dipsw_get( void );
unsigned char pushsw_get( void );
unsigned char startbar_get( void );
void led_out( unsigned char led );
void motor( int accele_l, int accele_r );
int diff( int pwm ); 
void handle( int angle );

/*======================================*/
/* グローバル変数の宣言                 */
/*======================================*/
unsigned long   cnt0;                   /* timer関数用                  */
unsigned long   cnt1;                   /* main内で使用                 */
int             pattern;                /* パターン番号                 */
int angle_buff; /* 現在ハンドル角度保持用 */ 

const revolution_difference[] = { /* 角度から内輪、外輪回転差計算 */ 
 100, 99, 97, 96, 95, 
 93, 92, 91, 89, 88, 
 87, 86, 84, 83, 82, 
 81, 79, 78, 77, 76, 
 75, 73, 72, 71, 70, 
 69, 67, 66, 65, 64, 
 62, 61, 60, 59, 58, 
 56, 55, 54, 52, 51, 
 50, 48, 47, 46, 44, 
 43 };

/************************************************************************/
/* メインプログラム                                                     */
/************************************************************************/
void main( void )
{
    int     i,Q;

    /* マイコン機能の初期化 */
    init();                             /* 初期化                       */
    asm(" fset I ");                    /* 全体の割り込み許可           */

    /* マイコンカーの状態初期化 */
    handle( 0 );
    motor( 0, 0 );

    while( 1 ) {
    switch( pattern ) {

    /*****************************************************************
    パターンについて    
     0：スイッチ入力待ち
     1：スタートバーが開いたかチェック
    11：通常トレース
    12：右へ大曲げの終わりのチェック
    13：左へ大曲げの終わりのチェック
    21：クロスライン検出時の処理
    22：クロスラインを読み飛ばす
    23：クロスライン後のトレース、クランク検出
    31：左クランククリア処理　安定するまで少し待つ
    32：左クランククリア処理　曲げ終わりのチェック
    41：右クランククリア処理　安定するまで少し待つ
    42：右クランククリア処理　曲げ終わりのチェック
    51：右ハーフライン検出時の処理
    52：右ハーフラインを読み飛ばす
    53：右ハーフライン後のトレース、レーンチェンジ
    54：右レーンチェンジ終了のチェック
    61：左ハーフライン検出時の処理
    62：左ハーフラインを読み飛ばす
    63：左ハーフライン後のトレース、レーンチェンジ
    64：左レーンチェンジ終了のチェック
    *****************************************************************/

    case 0:
        /* スイッチ入力待ち */
        if( pushsw_get() ) {
            pattern = 1;
            cnt1 = 0;
            break;
        }
        if( cnt1 < 100 ) {              /* LED点滅処理                  */
            led_out( 0x1 );
        } else if( cnt1 < 200 ) {
            led_out( 0x2 );
        } else {
            cnt1 = 0;
        }
        break;

    case 1:
        /* スタートバーが開いたかチェック */
        if( !startbar_get() ) {
            /* スタート！！ */
            led_out( 0x0 );
            pattern = 11;
            cnt1 = 0;
            break;
        }
        if( cnt1 < 50 ) {              /* LED点滅処理                   */
            led_out( 0x1 );
        } else if( cnt1 < 100 ) {
            led_out( 0x2 );
        } else {
            cnt1 = 0;
        }
        break;

    case 11:
        /* 通常トレース */
         Q=check_crossline() ;       /* クロスラインチェック         */
		 if(Q==21){
         pattern = 21;
         break;
        }
         if( Q==53) {       /* 右ハーフラインチェック       */
            pattern = 53;
            break;
        }
         if( Q==63 ) {        /* 左ハーフラインチェック       */
            pattern = 63;
            break;
        }
         switch( sensor_inp(MASK3_3) ) {
            case 0x00:
                /* センタ→まっすぐ */
                handle( 0 );
                M_MASSUGU;
                break;

            case 0x04:
                /* 微妙に左寄り→右へ微曲げ */
                handle( CV_S );
                M_MIGI_BI;
				break;

            case 0x06:
                /* 少し左寄り→右へ小曲げ */
                handle( CV_M );
                M_MIGI_KO;
                break;

            case 0x07:
                /* 中くらい左寄り→右へ中曲げ */
				handle( CV_L);
                M_MIGI_CHU;
                break;

            case 0x03:
                /* 大きく左寄り→右へ大曲げ */
                handle( CV_VL );
                M_MIGI_OO;
                pattern = 12;
                break;


            case 0x20:
                /* 微妙に右寄り→左へ微曲げ */
                handle( -CV_S );
                M_HIDARI_BI;
                break;

            case 0x60:
                /* 少し右寄り→左へ小曲げ */
                handle( -CV_M );
                M_HIDARI_KO;
				break;

            case 0xe0:
                /* 中くらい右寄り→左へ中曲げ */
                handle( -CV_L );
                M_HIDARI_CHU;
				break;

            case 0xc0:
                /* 大きく右寄り→左へ大曲げ */
                handle( -CV_VL );
                M_HIDARI_OO;
				pattern = 13;
                break;

            default:
                break;
        }
        break;

    case 12:
        /* 右へ大曲げの終わりのチェック */
		    Q=check_crossline();
        if( Q==21) {       /* 大曲げ中もクロスラインチェック */
            pattern = 21;
            break;
        }
        if( Q==53 ) {       /* 右ハーフラインチェック       */
            pattern = 53;
            break;
        }
        if( Q==63 ) {        /* 左ハーフラインチェック       */
            pattern = 63;
            break;
        }
        if( sensor_inp(MASK3_3) == 0x06 ) {
            pattern = 11;
        }
        break;

    case 13:
        /* 左へ大曲げの終わりのチェック */
		     Q=check_crossline();
        if( Q==21 ) {       /* 大曲げ中もクロスラインチェック */
            pattern = 21;
            break;
        }
        if( Q==51)  {       /* 右ハーフラインチェック       */
            pattern = 53;
            break;
        }
        if( Q==61 ) {        /* 左ハーフラインチェック       */
            pattern = 63;
            break;
        }
        if( sensor_inp(MASK3_3) == 0x60 ) {
            pattern = 11;
        }
        break;

    case 21:
        /* クロスライン検出時の処理 */
        led_out( 0x3 );
        handle( 0 );
		pattern = 22;
        cnt1 = 0;
		if ( CR_COUNT==3 ){
			motor( 0,0 );
			
		}
		if ( CR_COUNT==2){
			motor( CR_SPEED ,CR_SPEED );
			
		}
		if ( CR_COUNT==1){
			motor( 25 ,25 );
			
		}
		
		if ( CR_COUNT==4 ){
			motor( 0 ,0 );
			for(;;){}
			
		}
       // motor( CR_SPEED ,CR_SPEED );
        
		CR_COUNT++;
		
        break;

    case 22:
        /* クロスラインを読み飛ばす */
        if( cnt1 > 150 ) {
			motor( -100 , -100 );
            pattern = 23;
            cnt1 = 0;
        }
        break;

    case 23:
        /* クロスライン後のトレース、クランク検出 */
//        if( sensor_inp(MASK4_4)==0xf8 ) {
        if( sensor_inp(0xf0)==0xf0 ) {
            /* 左クランクと判断→左クランククリア処理へ */
            led_out( 0x1 );
            handle( -80 );
            motor( 0 ,100 );
            pattern = 31;
            cnt1 = 0;
            break;
        }
//        if( sensor_inp(MASK4_4)==0x1f ) {
        if( sensor_inp(0x0f)==0x0f ) {
            /* 右クランクと判断→右クランククリア処理へ */
            led_out( 0x2 );
            handle( 80 );
            motor( 100 ,0 );
            pattern = 41;
            cnt1 = 0;
            break;
        }
        switch( sensor_inp(MASK3_3) ) {
            case 0x00:
                /* センタ→まっすぐ */
                handle( 0 );
                motor( CR_SPEED ,CR_SPEED );
                break;
            case 0x04:
            case 0x06:
            case 0x07:
            case 0x03:
                /* 左寄り→右曲げ */
                handle( 8 );
                motor( CR_SPEED ,diff(CR_SPEED) );
                break;
            case 0x20:
            case 0x60:
            case 0xe0:
            case 0xc0:
                /* 右寄り→左曲げ */
                handle( -8 );
                motor( diff(CR_SPEED) ,CR_SPEED );
                break;
        }
        break;

    case 31:
        /* 左クランククリア処理　安定するまで少し待つ */
        if( cnt1 > 200 ) {
            pattern = 32;
            cnt1 = 0;
        }
        break;

    case 32:
        /* 左クランククリア処理　曲げ終わりのチェック */
        if( sensor_inp(MASK3_3) == 0x60 ) {
            led_out( 0x0 );
            pattern = 11;
            cnt1 = 0;
        }
        break;

    case 41:
        /* 右クランククリア処理　安定するまで少し待つ */
        if( cnt1 > 200 ) {
            pattern = 42;
            cnt1 = 0;
        }
        break;

    case 42:
        /* 右クランククリア処理　曲げ終わりのチェック */
        if( sensor_inp(MASK3_3) == 0x06 ) {
            led_out( 0x0 );
            pattern = 11;
            cnt1 = 0;
        }
        break;

    case 51:
        /* 右ハーフライン検出時の処理 */
        led_out( 0x2 );
        handle( 0 );
        motor( LC_SPEED ,LC_SPEED );
        pattern = 52;
        cnt1 = 0;
        break;

    case 52:
        /* 右ハーフラインを読み飛ばす */
        if( cnt1 > 100 ) {
            pattern = 53;
            cnt1 = 0;
        }
        break;

    case 53:
        /* 右ハーフライン後のトレース、レーンチェンジ */
        if( sensor_inp(MASK4_4) == 0x00 ) {
            handle( 20 );
			//15
            motor( 80 ,30 );
            pattern = 54;
            cnt1 = 0;
            break;
        }
        switch( sensor_inp(MASK3_3) ) {
            case 0x00:
                /* センタ→まっすぐ */
                handle( 0 );
                motor( LC_SPEED ,LC_SPEED );
                break;
            case 0x04:
            case 0x06:
            case 0x07:
            case 0x03:
                /* 左寄り→右曲げ */
                handle( 8 );
                motor( LC_SPEED ,diff(LC_SPEED) );
                break;
            case 0x20:
            case 0x60:
            case 0xe0:
            case 0xc0:
                /* 右寄り→左曲げ */
                handle( -8 );
                motor( diff(LC_SPEED) ,LC_SPEED );
                break;
            default:
                break;
        }
        break;

    case 54:
        /* 右レーンチェンジ終了のチェック */
 //       if( sensor_inp( 0x18 ) == 0x18 )
        if( sensor_inp( 0xe0 ) !=0 )
		 {
            led_out( 0x0 );
            pattern = 11;
            cnt1 = 0;
        }
        break;

    case 61:
		pattern = 11;
        /* 左ハーフライン検出時の処理 */
//        led_out( 0x1 );
//        handle( 0 );
//        motor( LC_SPEED,LC_SPEED );
//        pattern = 62;
//        cnt1 = 0;
        break;

    case 62:
        /* 左ハーフラインを読み飛ばす */
        if( cnt1 > 100 ) {
            pattern = 63;
            cnt1 = 0;
        }
        break;

    case 63:
        /* 左ハーフライン後のトレース、レーンチェンジ */
        if( sensor_inp(MASK4_4) == 0x00 ) {
            handle( -20 );
			//-15
            motor( 30 ,80 );
            pattern = 64;
            cnt1 = 0;
            break;
        }
        switch( sensor_inp(MASK3_3) ) {
            case 0x00:
                /* センタ→まっすぐ */
                handle( 0 );
                motor( LC_SPEED ,LC_SPEED );
                break;
            case 0x04:
            case 0x06:
            case 0x07:
            case 0x03:
                /* 左寄り→右曲げ */
                handle( 8 );
                motor( LC_SPEED ,diff(LC_SPEED) );
                break;
            case 0x20:
            case 0x60:
            case 0xe0:
            case 0xc0:
                /* 右寄り→左曲げ */
                handle( -8 );
                motor( diff(LC_SPEED) ,LC_SPEED );
                break;
            default:
                break;
        }
        break;

    case 64:
        /* 左レーンチェンジ終了のチェック */
 //       if( sensor_inp( 0x18 ) != 0 )
       if( sensor_inp( 0x07 ) != 0 )
		 {
			// handle( 20 );
			// motor( 0,0 );
			// motor( 10,-5 );
            led_out( 0x0 );
            pattern = 11;
            cnt1 = 0;
        }
        break;

    default:
        /* どれでもない場合は待機状態に戻す */
        pattern = 0;
        break;
    }
    }
}

/************************************************************************/
/* R8C/38A スペシャルファンクションレジスタ(SFR)の初期化                */
/************************************************************************/
void init( void )
{
    int i;

    /* クロックをXINクロック(20MHz)に変更 */
    prc0  = 1;                          /* プロテクト解除               */
    cm13  = 1;                          /* P4_6,P4_7をXIN-XOUT端子にする*/
    cm05  = 0;                          /* XINクロック発振              */
    for(i=0; i<50; i++ );               /* 安定するまで少し待つ(約10ms) */
    ocd2  = 0;                          /* システムクロックをXINにする  */
    prc0  = 0;                          /* プロテクトON                 */

    /* ポートの入出力設定 */
    prc2 = 1;                           /* PD0のプロテクト解除          */
    pd0 = 0x00;                         /* 7-0:センサ基板Ver.5          */
    pd1 = 0xd0;                         /* 5:RXD0 4:TXD0 3-0:DIP SW     */
    p2  = 0xc0;
    pd2 = 0xfe;                         /* 7-0:モータドライブ基板Ver.5  */
    pd3 = 0xff;                         /*                              */
    p4  = 0x20;                         /* P4_5のLED:初期は点灯         */
    pd4 = 0xb8;                         /* 7:XOUT 6:XIN 5:LED 2:VREF    */
    pd5 = 0xff;                         /*                              */
    pd6 = 0xff;                         /*                              */
    pd7 = 0xff;                         /*                              */
    pd8 = 0xff;                         /*                              */
    pd9 = 0x3f;                         /*                              */
    pur0 = 0x04;                        /* P1_3〜P1_0のプルアップON     */

    /* タイマRBの設定 */
    /* 割り込み周期 = 1 / 20[MHz]   * (TRBPRE+1) * (TRBPR+1)
                    = 1 / (20*10^6) * 200        * 100
                    = 0.001[s] = 1[ms]
    */
    trbmr  = 0x00;                      /* 動作モード、分周比設定       */
    trbpre = 200-1;                     /* プリスケーラレジスタ         */
    trbpr  = 100-1;                     /* プライマリレジスタ           */
    trbic  = 0x07;                      /* 割り込み優先レベル設定       */
    trbcr  = 0x01;                      /* カウント開始                 */

    /* タイマRD リセット同期PWMモードの設定*/
    /* PWM周期 = 1 / 20[MHz]   * カウントソース * (TRDGRA0+1)
               = 1 / (20*10^6) * 8              * 40000
               = 0.016[s] = 16[ms]
    */
    trdpsr0 = 0x08;                     /* TRDIOB0,C0,D0端子設定        */
    trdpsr1 = 0x05;                     /* TRDIOA1,B1,C1,D1端子設定     */
    trdmr   = 0xf0;                     /* バッファレジスタ設定         */
    trdfcr  = 0x01;                     /* リセット同期PWMモードに設定  */
    trdcr0  = 0x23;                     /* ソースカウントの選択:f8      */
    trdgra0 = trdgrc0 = PWM_CYCLE;      /* 周期                         */
    trdgrb0 = trdgrd0 = 0;              /* P2_2端子のON幅設定           */
    trdgra1 = trdgrc1 = 0;              /* P2_4端子のON幅設定           */
    trdgrb1 = trdgrd1 = SERVO_CENTER;   /* P2_5端子のON幅設定           */
    trdoer1 = 0xcd;                     /* 出力端子の選択               */
    trdstr  = 0x0d;                     /* TRD0カウント開始             */
}

/************************************************************************/
/* タイマRB 割り込み処理                                                */
/************************************************************************/
#pragma interrupt intTRB(vect=24)
void intTRB( void )
{
    cnt0++;
    cnt1++;
}

/************************************************************************/
/* タイマ本体                                                           */
/* 引数　 タイマ値 1=1ms                                                */
/************************************************************************/
void timer( unsigned long timer_set )
{
    cnt0 = 0;
    while( cnt0 < timer_set );
}

/************************************************************************/
/* センサ状態検出                                                       */
/* 引数　 マスク値                                                      */
/* 戻り値 センサ値                                                      */
/************************************************************************/
unsigned char sensor_inp( unsigned char mask )
{
    unsigned char sensor;

    sensor  = ~p0;

    sensor &= mask;

    return sensor;
}

/************************************************************************/
/* クロスライン検出処理                                                 */
/* 戻り値 0:クロスラインなし 1:あり                                     */
/************************************************************************/
int check_crossline( void )
{
    unsigned char b;
    int ret;

    ret = 0;
	
    b = sensor_inp(0x7e);
	
    if( b==0x7e) {
        ret = 21;
	    return ret;
	}
	
	b = sensor_inp(0x0f);
	
	if(b==0x0f){
		handle(0);
	//	motor(-200,-200);
		motor(LC_SPEED,LC_SPEED);
		led_out(0x2);
		cnt1=0;
		for(;;){
			if(cnt1>100){
				ret=53; break;
			}
			b=sensor_inp(0xf0);
			if(b==0xf0){
				ret=21; break;
			}
		}
		cnt1=0;
		return ret;
	}
	
	b=sensor_inp(0xf0);
	
	if(b==0xf0){
		handle(0);
//		motor(0,0);
		motor(LC_SPEED,LC_SPEED);
		led_out(0x1);
		cnt1=0;
		for(;;){
			if(cnt1>100){
				ret=63; break;
			}
			b=sensor_inp(0x0f);
			if(b==0x0f){
				ret=21; break;
			}
		}
		cnt1=0;
		return ret;
		}
	return ret;
}

/************************************************************************/
/* 右ハーフライン検出処理                                               */
/* 戻り値 0:なし 1:あり                                                 */
/************************************************************************/
//int check_rightline( void )
//{
//    unsigned char b;
//    int ret;

//    ret = 0;
//    b = sensor_inp(MASK4_4);
//    if( b==0x1f ) {
//        ret = 1;
//    }
//    return ret;
//}

/************************************************************************/
/* 左ハーフライン検出処理                                               */
/* 戻り値 0:なし 1:あり                                                 */
/************************************************************************/
//int check_leftline( void )
//{
//   unsigned char b;
//    int ret;

//    ret = 0;
//    b = sensor_inp(MASK4_4);
//   if( b==0xf8 ) {
//        ret = 1;
//    }
//    return ret;
//}

/************************************************************************/
/* ディップスイッチ値読み込み                                           */
/* 戻り値 スイッチ値 0〜15                                              */
/************************************************************************/
unsigned char dipsw_get( void )
{
    unsigned char sw;

    sw = p1 & 0x0f;                     /* P1_3〜P1_0読み込み           */

    return  sw;
}

/************************************************************************/
/* プッシュスイッチ値読み込み                                           */
/* 戻り値 スイッチ値 ON:1 OFF:0                                         */
/************************************************************************/
unsigned char pushsw_get( void )
{
    unsigned char sw;

    sw  = ~p2;                          /* スイッチのあるポート読み込み */
    sw &= 0x01;

    return  sw;
}

/************************************************************************/
/* スタートバー検出センサ読み込み                                       */
/* 戻り値 センサ値 ON(バーあり):1 OFF(なし):0                           */
/************************************************************************/
unsigned char startbar_get( void )
{
    unsigned char b;

    b  = ~p0;                           /* スタートバー信号読み込み     */
    b &= 0x01;

    return  b;
}

/************************************************************************/
/* LED制御                                                              */
/* 引数　スイッチ値 LED2:bit1 LED3:bit0  "0":消灯 "1":点灯              */
/* 例)0x3→LED2:ON LED3:ON  0x2→LED2:ON LED3:OFF                       */
/************************************************************************/
void led_out( unsigned char led )
{
    unsigned char data;

    led = ~led;
    led <<= 6;
    data = p2 & 0x3f;
    p2 = data | led;
}

/************************************************************************/
/* モータ速度制御                                                       */
/* 引数　 左モータ:-100〜100、右モータ:-100〜100                        */
/*        0で停止、100で正転100%、-100で逆転100%                        */
/* 戻り値 なし                                                          */
/************************************************************************/
void motor( int accele_l, int accele_r )
{
    int    sw_data;

    sw_data = dipsw_get() + 5;
   accele_l = accele_l * sw_data / 20;
   accele_r = accele_r * sw_data / 20;
	
    /* 左モータ制御 */
    if( accele_l >= 0 ) {
        p2 &= 0xfd;
        trdgrd0 = (long)( PWM_CYCLE - 1 ) * accele_l / 100;
    } else {
        p2 |= 0x02;
        trdgrd0 = (long)( PWM_CYCLE - 1 ) * ( -accele_l ) / 100;
    }

    /* 右モータ制御 */
    if( accele_r >= 0 ) {
        p2 &= 0xf7;
        trdgrc1 = (long)( PWM_CYCLE - 1 ) * accele_r / 100;
    } else {
        p2 |= 0x08;
        trdgrc1 = (long)( PWM_CYCLE - 1 ) * ( -accele_r ) / 100;
    }
}

/************************************************************************/
/* サーボハンドル操作                                                   */
/* 引数　 サーボ操作角度：-90〜90                                       */
/*        -90で左へ90度、0でまっすぐ、90で右へ90度回転                  */
/************************************************************************/
void handle( int angle )
{

	angle_buff = angle; /* 現在の角度保存 */ 


    /* サーボが左右逆に動く場合は、「-」を「+」に替えてください */
    trdgrd1 = SERVO_CENTER - angle * HANDLE_STEP;
}

/************************************************************************/ 
/* 外輪のPWMから、内輪のPWMを割り出す ハンドル角度は現在の値を使用 */ 
/* 引数 外輪PWM */ 
/* 戻り値 内輪PWM */ 
/************************************************************************/ 
int diff( int pwm ) 
{ 
 int ret; 
 
	 if( pwm >= 0 ) { 
	 /* PWM値が正の数なら */ 
	 if( angle_buff < 0 ) { 
	 angle_buff = -angle_buff; 
	 } 
	 ret = revolution_difference[angle_buff] * pwm / 100; 
	 } else { 
	 /* PWM値が負の数なら */ 
	 ret = pwm; /* そのまま返す */ 
	 } 
	 return ret; 
}


/************************************************************************/
/* end of file                                                          */
/************************************************************************/

